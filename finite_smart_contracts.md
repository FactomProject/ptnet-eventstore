Mathematically verifiable Smart Contracts without a common computing environment.

- Intro Smart Contracts
  - What is a smart contract?
  - What types of problems does a smart contract solve?
  - How can contracts be made secure?
  - Why should we solve this problem?
  - What does it mean to compute/execute a contract?
- Formal verification of software
  - Define computability
  - Explore Determinism vs Expressive power (DSL adjacent)
  - Boundedness
    - does my program have a halting state?
  - Proof: Curry-Howard Correspondence
    - does my solution model the problem?
  - Petri-Nets / Dual Petri-Nets
    - what are the possible outcomes of this program?
  - Synthesizing a Regular Language
    - How does a human interact with this?
- Application
  - Event-Sourcing with Blockchains
  - Vector Addition Systems with State
  - Off-chain verifiable computation
- Conclusion & Future - Math is a universal protocol
  - Secure publishing of event schemata on Factom blockchain
  - Evolving future protocols and paradigms with a data layer.
- Bibliography

How do you verify the statement: "It's raining outside."?

Ask someone - trust (we know the source)
Look out a window - verify (appears to be correct)
Go outside - validate (first hand experience)
Other evidence - hypothesize (we can use science to find out)

The ideal smart contract provides evidence for testing the hypothesis of trust.
This allows the reality of the outside world to be compared with the state of the blockchain.

Why is trust valuable?
- Ideally leading to a frictionless digital economy.
- Adds liquidity to business relationships.
